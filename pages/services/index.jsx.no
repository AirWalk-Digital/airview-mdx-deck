
import React, { useState, useEffect, useCallback, useRef } from 'react'
import { VFile } from 'vfile'
import { VFileMessage } from 'vfile-message'
import * as provider from '@mdx-js/react'
import * as runtime from 'react/jsx-runtime'
// import {statistics} from 'vfile-statistics'
// import {reporter} from 'vfile-reporter'
import { evaluate } from '@mdx-js/mdx'
import remarkGfm from 'remark-gfm'
import remarkFrontmatter from 'remark-frontmatter'
import remarkMdxFrontmatter from 'remark-mdx-frontmatter'
import remarkUnwrapImages from 'remark-unwrap-images';
import { Box, Typography } from '@mui/material';
// import remarkMath from 'remark-math'
import { ErrorBoundary } from 'react-error-boundary'
import { useDebounceFn } from 'ahooks'
import dynamic from 'next/dynamic'
import { useRouter } from 'next/router';
import { theme } from '../../constants/baseTheme';
import { ThemeProvider } from '@mui/material/styles';
import CssBaseline from '@mui/material/CssBaseline';
import { mdComponents } from "../../constants/mdxProvider";
import * as matter from 'gray-matter';
import Topbar from '../../components/TopBar';

import { MDXProvider } from '@mdx-js/react';

import { Menu, NavigationDrawer } from '../../components/airview-ui';
import { getAllFiles, getFileContent, getAllDirectories } from '../../backend/filesystem';


export default function Services(content) {
  

  return (
    <DefaultView frontmatter={state && state.file && state.file.frontmatter ? state.file.frontmatter : {}} >
    
        {/* <Preview components={mdComponents} /> */}
        {/* {state && state.file && state.file.result ? (<Preview components={mdComponents} />) : null} */}

    </DefaultView>
  )
};




function DefaultView({
  children, // will be a page or nested layout
  frontmatter = null // frontmatter collected from the page and the mdx file
}) {

  const navItemsControls = [
    {
      groupTitle: "Menu Group Title One",
      links: [
        {
          label: "Menu Item One",
          url: "",
        },
        {
          label: "Menu Item Two",
          url: "",
        },
      ],
    },
    {
      groupTitle: "Menu Group Title Two",
      links: [
        {
          label: "Menu Item One",
          url: "",
        },
        {
          label: "Menu Item Two",
          url: "",
        },
      ],
    },
  ];

  const navItemsDocs = [
    {
      groupTitle: "Infrastructure-as-Code",
      links: [
        {
          label: "terraform-azure-storage",
          url: "",
        },
      ],
    },
    {
      groupTitle: "Designs",
      links: [
        {
          label: "Static Content Website",
          url: "",
        },
        {
          label: "Data Lakes",
          url: "",
        },
      ],
    },
  ];
  const navDrawerWidth = 300;
  const topBarHeight = 64;
  const [menuOpen, setMenuOpen] = useState(true);

  const handleOnNavButtonClick = () => setMenuOpen((prevState) => !prevState);
  console.log(frontmatter);
  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <Topbar onNavButtonClick={handleOnNavButtonClick}
        navOpen={menuOpen}
        menu={true}
        topBarHeight={topBarHeight} />
      
     <Box sx={{ px: '5%' }}>
          {frontmatter.title && <Typography variant="h1" component="h1">{frontmatter.title}</Typography>}
          <MDXProvider components={mdComponents}>
            {children}
          </MDXProvider>
        </Box>
    </ThemeProvider>
  )
}


export async function getStaticPaths() {
  let pages = [];
  let location = 'services';
  try {
    const files = await getAllFiles(location)

    const pages = files.map((file) => {

      if (file.endsWith('index.md') || file.endsWith('index.mdx')) {
        const filepath = file.split('/');
        filepath.pop();
        const joinedPath = filepath.join('/');
        return joinedPath;
              } else {
        return file
      }
    })

    // console.log('getStaticPaths: ',pages )
    return {
      fallback: true,
      paths: pages
    }
  } catch (error) {
    console.error(error)
    return {
      fallback: true,
      paths: pages
    }
  }


}

function getCSP() {
 let folders = getAllDirectories('services');
 let csp = [];
 for (csp of folders) {
  console.log('csp: ' , csp)
  const filepath = csp.split('/');
}
}

function getServicesByCSP(csp) {

}

export async function getStaticProps() {
  const csp = getCSP();
  let services = [];
  let location = 'services';
  try {
    const files = await getAllFiles(location)

    const pages = files.map((file) => {

      if (file.endsWith('index.md') || file.endsWith('index.mdx')) {
        const filepath = file.split('/');
        filepath.pop();
        const joinedPath = filepath.join('/');
        return joinedPath;
              } else {
        return file
      }
    }) } catch (error) {
      console.error(error)
    }


  location = 'services/' + 'tmp' + '/index.mdx';
  // console.log('getStaticProps: ',location )

  try {
    const content = await getFileContent(location) // Pass null or an empty string for filePath
    return {
      props: {
        content: content,
      },
    }
  } catch (error) {
    console.error(error)
    return {
      props: {
        content: [],
      },
    }
  }
}